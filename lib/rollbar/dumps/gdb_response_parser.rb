# Copyright 2009 Martin Carpenter. All rights reserved.
# Autogenerated from a Treetop grammar. Edits may be lost.



# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:

#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.

#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.

module GdbResponse
  include Treetop::Runtime

  def root
    @root ||= :response
  end

  def _nt_response
    start_index = index
    if node_cache[:response].has_key?(index)
      cached = node_cache[:response][index]
      if cached
        node_cache[:response][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_initial_output
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_output
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_notification
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_final_output
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:response][start_index] = r0

    r0
  end

  def _nt_initial_output
    start_index = index
    if node_cache[:initial_output].has_key?(index)
      cached = node_cache[:initial_output][index]
      if cached
        node_cache[:initial_output][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_terminator

    node_cache[:initial_output][start_index] = r0

    r0
  end

  module Exception0
    def signal
      elements[1]
    end

    def exception_message
      elements[2]
    end
  end

  def _nt_exception
    start_index = index
    if node_cache[:exception].has_key?(index)
      cached = node_cache[:exception][index]
      if cached
        node_cache[:exception][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("Program terminated with signal", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"Program terminated with signal"')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_signal
      s0 << r2
      if r2
        r3 = _nt_exception_message
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Exception0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:exception][start_index] = r0

    r0
  end

  module Signal0
  end

  def _nt_signal
    start_index = index
    if node_cache[:signal].has_key?(index)
      cached = node_cache[:signal][index]
      if cached
        node_cache[:signal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if index < input_length
      r1 = true
      @index += 1
    else
      terminal_parse_failure("any character")
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?(",", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('","')
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Signal0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:signal][start_index] = r0

    r0
  end

  def _nt_exception_message
    start_index = index
    if node_cache[:exception_message].has_key?(index)
      cached = node_cache[:exception_message][index]
      if cached
        node_cache[:exception_message][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if index < input_length
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("any character")
      r0 = nil
    end

    node_cache[:exception_message][start_index] = r0

    r0
  end

  module FinalOutput0
    def _token
      elements[0]
    end

    def eol
      elements[2]
    end
  end

  def _nt_final_output
    start_index = index
    if node_cache[:final_output].has_key?(index)
      cached = node_cache[:final_output][index]
      if cached
        node_cache[:final_output][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_token
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('^exit', false, index))
        r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'^exit\'')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_eol
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::FinalResponse,input, i0...index, s0)
      r0.extend(FinalOutput0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:final_output][start_index] = r0

    r0
  end

  module Output0
    def _oob_records1
      elements[0]
    end

    def _result_record
      elements[1]
    end

    def _oob_records2
      elements[2]
    end

    def terminator
      elements[3]
    end
  end

  def _nt_output
    start_index = index
    if node_cache[:output].has_key?(index)
      cached = node_cache[:output][index]
      if cached
        node_cache[:output][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_oob_record
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r3 = _nt_result_record
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_oob_record
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
        if r4
          r6 = _nt_terminator
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::Response,input, i0...index, s0)
      r0.extend(Output0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:output][start_index] = r0

    r0
  end

  module Notification0
    def _oob_records
      elements[0]
    end

    def terminator
      elements[1]
    end
  end

  def _nt_notification
    start_index = index
    if node_cache[:notification].has_key?(index)
      cached = node_cache[:notification][index]
      if cached
        node_cache[:notification][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_oob_record
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r3 = _nt_terminator
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::Notification,input, i0...index, s0)
      r0.extend(Notification0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:notification][start_index] = r0

    r0
  end

  module ResultRecord0
    def comma
      elements[0]
    end

    def _result
      elements[1]
    end
  end

  module ResultRecord1
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _record_class
      elements[2]
    end

    def _results
      elements[3]
    end

    def eol
      elements[4]
    end
  end

  def _nt_result_record
    start_index = index
    if node_cache[:result_record].has_key?(index)
      cached = node_cache[:result_record][index]
      if cached
        node_cache[:result_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_token
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('^', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'^\'')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_result_class
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            i6, s6 = index, []
            r7 = _nt_comma
            s6 << r7
            if r7
              r8 = _nt_result
              s6 << r8
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(ResultRecord0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            r9 = _nt_eol
            s0 << r9
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::ResultRecord,input, i0...index, s0)
      r0.extend(ResultRecord1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:result_record][start_index] = r0

    r0
  end

  module OobRecord0
    def comma
      elements[0]
    end

    def _result
      elements[1]
    end
  end

  module OobRecord1
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _record_class
      elements[2]
    end

    def _results
      elements[3]
    end

    def eol
      elements[4]
    end
  end

  module OobRecord2
    def comma
      elements[0]
    end

    def _result
      elements[1]
    end
  end

  module OobRecord3
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _record_class
      elements[2]
    end

    def _results
      elements[3]
    end

    def eol
      elements[4]
    end
  end

  module OobRecord4
    def comma
      elements[0]
    end

    def _result
      elements[1]
    end
  end

  module OobRecord5
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _record_class
      elements[2]
    end

    def _results
      elements[3]
    end

    def eol
      elements[4]
    end
  end

  module OobRecord6
    def comma
      elements[0]
    end

    def _result
      elements[1]
    end
  end

  module OobRecord7
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _record_class
      elements[2]
    end

    def _results
      elements[3]
    end

    def eol
      elements[4]
    end
  end

  module OobRecord8
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _results
      elements[2]
    end

    def eol
      elements[3]
    end
  end

  module OobRecord9
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _results
      elements[2]
    end

    def eol
      elements[3]
    end
  end

  module OobRecord10
    def _token
      elements[0]
    end

    def _record_type
      elements[1]
    end

    def _results
      elements[2]
    end

    def eol
      elements[3]
    end
  end

  def _nt_oob_record
    start_index = index
    if node_cache[:oob_record].has_key?(index)
      cached = node_cache[:oob_record][index]
      if cached
        node_cache[:oob_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_token
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      if (match_len = has_terminal?('*', false, index))
        r4 = true
        @index += match_len
      else
        terminal_parse_failure('\'*\'')
        r4 = nil
      end
      s1 << r4
      if r4
        r5 = _nt_async_class
        s1 << r5
        if r5
          s6, i6 = [], index
          loop do
            i7, s7 = index, []
            r8 = _nt_comma
            s7 << r8
            if r8
              r9 = _nt_result
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(OobRecord0)
            else
              @index = i7
              r7 = nil
            end
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s1 << r6
          if r6
            r10 = _nt_eol
            s1 << r10
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(Rollbar::Dumps::AsyncExecRecord,input, i1...index, s1)
      r1.extend(OobRecord1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i11, s11 = index, []
      r13 = _nt_token
      if r13
        r12 = r13
      else
        r12 = instantiate_node(SyntaxNode,input, index...index)
      end
      s11 << r12
      if r12
        if (match_len = has_terminal?('*', false, index))
          r14 = true
          @index += match_len
        else
          terminal_parse_failure('\'*\'')
          r14 = nil
        end
        s11 << r14
        if r14
          r15 = _nt_result_class
          s11 << r15
          if r15
            s16, i16 = [], index
            loop do
              i17, s17 = index, []
              r18 = _nt_comma
              s17 << r18
              if r18
                r19 = _nt_result
                s17 << r19
              end
              if s17.last
                r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
                r17.extend(OobRecord2)
              else
                @index = i17
                r17 = nil
              end
              if r17
                s16 << r17
              else
                break
              end
            end
            r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
            s11 << r16
            if r16
              r20 = _nt_eol
              s11 << r20
            end
          end
        end
      end
      if s11.last
        r11 = instantiate_node(Rollbar::Dumps::AsyncExecRecord,input, i11...index, s11)
        r11.extend(OobRecord3)
      else
        @index = i11
        r11 = nil
      end
      if r11
        r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
        r0 = r11
      else
        i21, s21 = index, []
        r23 = _nt_token
        if r23
          r22 = r23
        else
          r22 = instantiate_node(SyntaxNode,input, index...index)
        end
        s21 << r22
        if r22
          if (match_len = has_terminal?('+', false, index))
            r24 = true
            @index += match_len
          else
            terminal_parse_failure('\'+\'')
            r24 = nil
          end
          s21 << r24
          if r24
            r25 = _nt_async_class
            s21 << r25
            if r25
              s26, i26 = [], index
              loop do
                i27, s27 = index, []
                r28 = _nt_comma
                s27 << r28
                if r28
                  r29 = _nt_result
                  s27 << r29
                end
                if s27.last
                  r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                  r27.extend(OobRecord4)
                else
                  @index = i27
                  r27 = nil
                end
                if r27
                  s26 << r27
                else
                  break
                end
              end
              r26 = instantiate_node(SyntaxNode,input, i26...index, s26)
              s21 << r26
              if r26
                r30 = _nt_eol
                s21 << r30
              end
            end
          end
        end
        if s21.last
          r21 = instantiate_node(Rollbar::Dumps::AsyncStatusRecord,input, i21...index, s21)
          r21.extend(OobRecord5)
        else
          @index = i21
          r21 = nil
        end
        if r21
          r21 = SyntaxNode.new(input, (index-1)...index) if r21 == true
          r0 = r21
        else
          i31, s31 = index, []
          r33 = _nt_token
          if r33
            r32 = r33
          else
            r32 = instantiate_node(SyntaxNode,input, index...index)
          end
          s31 << r32
          if r32
            if (match_len = has_terminal?('=', false, index))
              r34 = true
              @index += match_len
            else
              terminal_parse_failure('\'=\'')
              r34 = nil
            end
            s31 << r34
            if r34
              r35 = _nt_async_class
              s31 << r35
              if r35
                s36, i36 = [], index
                loop do
                  i37, s37 = index, []
                  r38 = _nt_comma
                  s37 << r38
                  if r38
                    r39 = _nt_result
                    s37 << r39
                  end
                  if s37.last
                    r37 = instantiate_node(SyntaxNode,input, i37...index, s37)
                    r37.extend(OobRecord6)
                  else
                    @index = i37
                    r37 = nil
                  end
                  if r37
                    s36 << r37
                  else
                    break
                  end
                end
                r36 = instantiate_node(SyntaxNode,input, i36...index, s36)
                s31 << r36
                if r36
                  r40 = _nt_eol
                  s31 << r40
                end
              end
            end
          end
          if s31.last
            r31 = instantiate_node(Rollbar::Dumps::AsyncNotifyRecord,input, i31...index, s31)
            r31.extend(OobRecord7)
          else
            @index = i31
            r31 = nil
          end
          if r31
            r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
            r0 = r31
          else
            i41, s41 = index, []
            r43 = _nt_token
            if r43
              r42 = r43
            else
              r42 = instantiate_node(SyntaxNode,input, index...index)
            end
            s41 << r42
            if r42
              if (match_len = has_terminal?('~', false, index))
                r44 = true
                @index += match_len
              else
                terminal_parse_failure('\'~\'')
                r44 = nil
              end
              s41 << r44
              if r44
                r45 = _nt_c_string
                s41 << r45
                if r45
                  r46 = _nt_eol
                  s41 << r46
                end
              end
            end
            if s41.last
              r41 = instantiate_node(Rollbar::Dumps::StreamConsoleRecord,input, i41...index, s41)
              r41.extend(OobRecord8)
            else
              @index = i41
              r41 = nil
            end
            if r41
              r41 = SyntaxNode.new(input, (index-1)...index) if r41 == true
              r0 = r41
            else
              i47, s47 = index, []
              r49 = _nt_token
              if r49
                r48 = r49
              else
                r48 = instantiate_node(SyntaxNode,input, index...index)
              end
              s47 << r48
              if r48
                if (match_len = has_terminal?('@', false, index))
                  r50 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'@\'')
                  r50 = nil
                end
                s47 << r50
                if r50
                  r51 = _nt_c_string
                  s47 << r51
                  if r51
                    r52 = _nt_eol
                    s47 << r52
                  end
                end
              end
              if s47.last
                r47 = instantiate_node(Rollbar::Dumps::StreamTargetRecord,input, i47...index, s47)
                r47.extend(OobRecord9)
              else
                @index = i47
                r47 = nil
              end
              if r47
                r47 = SyntaxNode.new(input, (index-1)...index) if r47 == true
                r0 = r47
              else
                i53, s53 = index, []
                r55 = _nt_token
                if r55
                  r54 = r55
                else
                  r54 = instantiate_node(SyntaxNode,input, index...index)
                end
                s53 << r54
                if r54
                  if (match_len = has_terminal?('&', false, index))
                    r56 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'&\'')
                    r56 = nil
                  end
                  s53 << r56
                  if r56
                    r57 = _nt_c_string
                    s53 << r57
                    if r57
                      r58 = _nt_eol
                      s53 << r58
                    end
                  end
                end
                if s53.last
                  r53 = instantiate_node(Rollbar::Dumps::StreamLogRecord,input, i53...index, s53)
                  r53.extend(OobRecord10)
                else
                  @index = i53
                  r53 = nil
                end
                if r53
                  r53 = SyntaxNode.new(input, (index-1)...index) if r53 == true
                  r0 = r53
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:oob_record][start_index] = r0

    r0
  end

  def _nt_result_class
    start_index = index
    if node_cache[:result_class].has_key?(index)
      cached = node_cache[:result_class][index]
      if cached
        node_cache[:result_class][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?('done', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'done\'')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?('running', false, index))
        r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'running\'')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        if (match_len = has_terminal?('connected', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'connected\'')
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          if (match_len = has_terminal?('error', false, index))
            r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'error\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            if (match_len = has_terminal?('exit', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'exit\'')
              r5 = nil
            end
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:result_class][start_index] = r0

    r0
  end

  def _nt_async_class
    start_index = index
    if node_cache[:async_class].has_key?(index)
      cached = node_cache[:async_class][index]
      if cached
        node_cache[:async_class][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?('stopped', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'stopped\'')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?('thread-group-started', false, index))
        r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'thread-group-started\'')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        if (match_len = has_terminal?('thread-group-added', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'thread-group-added\'')
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          if (match_len = has_terminal?('thread-created', false, index))
            r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'thread-created\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            if (match_len = has_terminal?('thread-exited', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'thread-exited\'')
              r5 = nil
            end
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              if (match_len = has_terminal?('thread-group-exited', false, index))
                r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'thread-group-exited\'')
                r6 = nil
              end
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r0 = r6
              else
                if (match_len = has_terminal?('library-loaded', false, index))
                  r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'library-loaded\'')
                  r7 = nil
                end
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r0 = r7
                else
                  if (match_len = has_terminal?('breakpoint-modified', false, index))
                    r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'breakpoint-modified\'')
                    r8 = nil
                  end
                  if r8
                    r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                    r0 = r8
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:async_class][start_index] = r0

    r0
  end

  module Result0
    def _name
      elements[0]
    end

    def _value
      elements[2]
    end
  end

  def _nt_result
    start_index = index
    if node_cache[:result].has_key?(index)
      cached = node_cache[:result][index]
      if cached
        node_cache[:result][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable
    s0 << r1
    if r1
      if (match_len = has_terminal?('=', false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('\'=\'')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_value
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::Result,input, i0...index, s0)
      r0.extend(Result0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:result][start_index] = r0

    r0
  end

  module Variable0
  end

  def _nt_variable
    start_index = index
    if node_cache[:variable].has_key?(index)
      cached = node_cache[:variable][index]
      if cached
        node_cache[:variable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?(@regexps[gr = '\A[a-zA-Z]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[a-zA-Z]')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9\\-]'] ||= Regexp.new(gr), :regexp, index)
          r3 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9\\-]')
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::Name,input, i0...index, s0)
      r0.extend(Variable0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:variable][start_index] = r0

    r0
  end

  def _nt_value
    start_index = index
    if node_cache[:value].has_key?(index)
      cached = node_cache[:value][index]
      if cached
        node_cache[:value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_const
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_tuple
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_list
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:value][start_index] = r0

    r0
  end

  def _nt_const
    start_index = index
    if node_cache[:const].has_key?(index)
      cached = node_cache[:const][index]
      if cached
        node_cache[:const][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_c_string

    node_cache[:const][start_index] = r0

    r0
  end

  def _nt_comma
    start_index = index
    if node_cache[:comma].has_key?(index)
      cached = node_cache[:comma][index]
      if cached
        node_cache[:comma][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?(',', false, index))
      r0 = instantiate_node(Rollbar::Dumps::Punctuation,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\',\'')
      r0 = nil
    end

    node_cache[:comma][start_index] = r0

    r0
  end

  def _nt_openbrace
    start_index = index
    if node_cache[:openbrace].has_key?(index)
      cached = node_cache[:openbrace][index]
      if cached
        node_cache[:openbrace][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('{', false, index))
      r0 = instantiate_node(Rollbar::Dumps::Punctuation,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'{\'')
      r0 = nil
    end

    node_cache[:openbrace][start_index] = r0

    r0
  end

  def _nt_closebrace
    start_index = index
    if node_cache[:closebrace].has_key?(index)
      cached = node_cache[:closebrace][index]
      if cached
        node_cache[:closebrace][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('}', false, index))
      r0 = instantiate_node(Rollbar::Dumps::Punctuation,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'}\'')
      r0 = nil
    end

    node_cache[:closebrace][start_index] = r0

    r0
  end

  def _nt_openbracket
    start_index = index
    if node_cache[:openbracket].has_key?(index)
      cached = node_cache[:openbracket][index]
      if cached
        node_cache[:openbracket][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('[', false, index))
      r0 = instantiate_node(Rollbar::Dumps::Punctuation,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'[\'')
      r0 = nil
    end

    node_cache[:openbracket][start_index] = r0

    r0
  end

  def _nt_closebracket
    start_index = index
    if node_cache[:closebracket].has_key?(index)
      cached = node_cache[:closebracket][index]
      if cached
        node_cache[:closebracket][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?(']', false, index))
      r0 = instantiate_node(Rollbar::Dumps::Punctuation,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\']\'')
      r0 = nil
    end

    node_cache[:closebracket][start_index] = r0

    r0
  end

  module Tuple0
    def openbrace
      elements[0]
    end

    def closebrace
      elements[1]
    end
  end

  module Tuple1
    def comma
      elements[0]
    end

    def result
      elements[1]
    end
  end

  module Tuple2
    def openbrace
      elements[0]
    end

    def result
      elements[1]
    end

    def closebrace
      elements[3]
    end
  end

  def _nt_tuple
    start_index = index
    if node_cache[:tuple].has_key?(index)
      cached = node_cache[:tuple][index]
      if cached
        node_cache[:tuple][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_openbrace
    s1 << r2
    if r2
      r3 = _nt_closebrace
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(Rollbar::Dumps::Tuple,input, i1...index, s1)
      r1.extend(Tuple0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_openbrace
      s4 << r5
      if r5
        r6 = _nt_result
        s4 << r6
        if r6
          s7, i7 = [], index
          loop do
            i8, s8 = index, []
            r9 = _nt_comma
            s8 << r9
            if r9
              r10 = _nt_result
              s8 << r10
            end
            if s8.last
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              r8.extend(Tuple1)
            else
              @index = i8
              r8 = nil
            end
            if r8
              s7 << r8
            else
              break
            end
          end
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          s4 << r7
          if r7
            r11 = _nt_closebrace
            s4 << r11
          end
        end
      end
      if s4.last
        r4 = instantiate_node(Rollbar::Dumps::Tuple,input, i4...index, s4)
        r4.extend(Tuple2)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
        r0 = r4
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:tuple][start_index] = r0

    r0
  end

  module List0
    def openbracket
      elements[0]
    end

    def closebracket
      elements[1]
    end
  end

  module List1
    def comma
      elements[0]
    end

    def value
      elements[1]
    end
  end

  module List2
    def openbracket
      elements[0]
    end

    def value
      elements[1]
    end

    def closebracket
      elements[3]
    end
  end

  module List3
    def comma
      elements[0]
    end

    def result
      elements[1]
    end
  end

  module List4
    def openbracket
      elements[0]
    end

    def result
      elements[1]
    end

    def closebracket
      elements[3]
    end
  end

  def _nt_list
    start_index = index
    if node_cache[:list].has_key?(index)
      cached = node_cache[:list][index]
      if cached
        node_cache[:list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_openbracket
    s1 << r2
    if r2
      r3 = _nt_closebracket
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(Rollbar::Dumps::List,input, i1...index, s1)
      r1.extend(List0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_openbracket
      s4 << r5
      if r5
        r6 = _nt_value
        s4 << r6
        if r6
          s7, i7 = [], index
          loop do
            i8, s8 = index, []
            r9 = _nt_comma
            s8 << r9
            if r9
              r10 = _nt_value
              s8 << r10
            end
            if s8.last
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              r8.extend(List1)
            else
              @index = i8
              r8 = nil
            end
            if r8
              s7 << r8
            else
              break
            end
          end
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          s4 << r7
          if r7
            r11 = _nt_closebracket
            s4 << r11
          end
        end
      end
      if s4.last
        r4 = instantiate_node(Rollbar::Dumps::List,input, i4...index, s4)
        r4.extend(List2)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
        r0 = r4
      else
        i12, s12 = index, []
        r13 = _nt_openbracket
        s12 << r13
        if r13
          r14 = _nt_result
          s12 << r14
          if r14
            s15, i15 = [], index
            loop do
              i16, s16 = index, []
              r17 = _nt_comma
              s16 << r17
              if r17
                r18 = _nt_result
                s16 << r18
              end
              if s16.last
                r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                r16.extend(List3)
              else
                @index = i16
                r16 = nil
              end
              if r16
                s15 << r16
              else
                break
              end
            end
            r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
            s12 << r15
            if r15
              r19 = _nt_closebracket
              s12 << r19
            end
          end
        end
        if s12.last
          r12 = instantiate_node(Rollbar::Dumps::List,input, i12...index, s12)
          r12.extend(List4)
        else
          @index = i12
          r12 = nil
        end
        if r12
          r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
          r0 = r12
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:list][start_index] = r0

    r0
  end

  module CString0
    def _unquoted_c_string
      elements[1]
    end

  end

  def _nt_c_string
    start_index = index
    if node_cache[:c_string].has_key?(index)
      cached = node_cache[:c_string][index]
      if cached
        node_cache[:c_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('"', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'"\'')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        r4 = _nt_c_escaped_quote
        if r4
          r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
          r3 = r4
        else
          r5 = _nt_c_char
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r3 = r5
          else
            @index = i3
            r3 = nil
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if (match_len = has_terminal?('"', false, index))
          r6 = true
          @index += match_len
        else
          terminal_parse_failure('\'"\'')
          r6 = nil
        end
        s0 << r6
      end
    end
    if s0.last
      r0 = instantiate_node(Rollbar::Dumps::Const,input, i0...index, s0)
      r0.extend(CString0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:c_string][start_index] = r0

    r0
  end

  def _nt_c_escaped_quote
    start_index = index
    if node_cache[:c_escaped_quote].has_key?(index)
      cached = node_cache[:c_escaped_quote][index]
      if cached
        node_cache[:c_escaped_quote][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('\\"', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'\\\\"\'')
      r0 = nil
    end

    node_cache[:c_escaped_quote][start_index] = r0

    r0
  end

  module CChar0
  end

  def _nt_c_char
    start_index = index
    if node_cache[:c_char].has_key?(index)
      cached = node_cache[:c_char][index]
      if cached
        node_cache[:c_char][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    if (match_len = has_terminal?('"', false, index))
      r2 = true
      @index += match_len
    else
      terminal_parse_failure('\'"\'')
      r2 = nil
    end
    if r2
      @index = i1
      r1 = nil
      terminal_parse_failure('\'"\'', true)
    else
      @terminal_failures.pop
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if index < input_length
        r3 = true
        @index += 1
      else
        terminal_parse_failure("any character")
        r3 = nil
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CChar0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:c_char][start_index] = r0

    r0
  end

  def _nt_token
    start_index = index
    if node_cache[:token].has_key?(index)
      cached = node_cache[:token][index]
      if cached
        node_cache[:token][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[\\d]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:token][start_index] = r0

    r0
  end

  module Terminator0
    def eol
      elements[2]
    end
  end

  def _nt_terminator
    start_index = index
    if node_cache[:terminator].has_key?(index)
      cached = node_cache[:terminator][index]
      if cached
        node_cache[:terminator][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('(gdb)', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'(gdb)\'')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_hspace
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_eol
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Terminator0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:terminator][start_index] = r0

    r0
  end

  def _nt_hspace
    start_index = index
    if node_cache[:hspace].has_key?(index)
      cached = node_cache[:hspace][index]
      if cached
        node_cache[:hspace][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[ \\t]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[ \\t]')
      r0 = nil
    end

    node_cache[:hspace][start_index] = r0

    r0
  end

  def _nt_eol
    start_index = index
    if node_cache[:eol].has_key?(index)
      cached = node_cache[:eol][index]
      if cached
        node_cache[:eol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?("\r\n", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"\\r\\n"')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?("\n", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"\\n"')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:eol][start_index] = r0

    r0
  end

end

class GdbResponseParser < Treetop::Runtime::CompiledParser
  include GdbResponse
end

